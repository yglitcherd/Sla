-- Carrega a biblioteca Rayfield
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Referências aos serviços
local lp = game.Players.LocalPlayer
local rs = game:GetService("ReplicatedStorage")
local workspace = game:GetService("Workspace")
local ts = game:GetService("TweenService")

-- Cria a interface da Rayfield
local Window = Rayfield:CreateWindow({
    Name = "Auto Miner",
    LoadingTitle = "Carregando Auto Miner",
    LoadingSubtitle = "by SeuNome",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil, -- Usa pasta padrão
        FileName = "AutoMinerConfig"
    }
})

-- Cria uma aba
local Tab = Window:CreateTab("Mineração", nil)

-- Variáveis para controlar os estados dos loops
local isMiningSelected = false
local isMiningRarest = false
local isMiningNormal = false
local selectedOre = "Stone" -- Minério padrão
local originalCFrame = nil -- Armazena o CFrame original antes de ativar o Auto Miner

-- Tabela de minérios com raridades (baseada na tabela v3)
local oreRarities = {
    Darkstone = 99,
    Stone = 98,
    Copper = 0.5,
    Coal = 0.5,
    Iron = 0.5,
    Ruby = 0.5,
    Diamond = 0.25,
    ["Abyssal Stone"] = 0.1,
    Ambrosia = 0.1,
    Ammolite = 0.1,
    Platinum = 0.1,
    Dragonglass = 0.1,
    Plutonium = 0.1,
    Datolite = 0.05,
    Firecrystal = 0.05,
    Darkmatter = 0.05,
    Garnet = 0.01,
    Lithium = 0.01,
    Rainbonite = 0.01,
    Stellarite = 0.01,
    Constellatium = 0.005,
    Superium = 0.0001,
    Laventyx = 0.0001,
    Eclipse = 0.00001,
    Yumium = 0.00001
}

-- Lista de minérios em ordem de raridade (decrescente)
local oreList = {
    "Darkstone", "Stone", "Copper", "Chest", "Coal", "Iron", "Ruby", "Diamond",
    "Abyssal Stone", "Ambrosia", "Ammolite", "Platinum", "Dragonglass", "Plutonium",
    "Datolite", "Firecrystal", "Darkmatter", "Garnet", "Lithium", "Rainbonite",
    "Stellarite", "Constellatium", "Superium", "Laventyx", "Eclipse", "Yumium"
}

-- Função para encontrar o minério mais próximo do tipo especificado
local function getNearestOre(oreName)
    if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then
        return nil
    end
    local hrp = lp.Character.HumanoidRootPart
    
    local nearest, distance = nil, math.huge
    for _, ore in pairs(workspace.Ores:GetChildren()) do
        if ore:IsA("BasePart") and ore.Name == oreName then
            local dist = (ore.Position - hrp.Position).Magnitude
            if dist < distance then
                distance = dist
                nearest = ore
            end
        end
    end
    return nearest
end

-- Função para encontrar o minério mais próximo (qualquer tipo)
local function getNearestAnyOre()
    if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then
        return nil
    end
    local hrp = lp.Character.HumanoidRootPart
    
    local nearest, distance = nil, math.huge
    for _, ore in pairs(workspace.Ores:GetChildren()) do
        if ore:IsA("BasePart") then
            local dist = (ore.Position - hrp.Position).Magnitude
            if dist < distance then
                distance = dist
                nearest = ore
            end
        end
    end
    return nearest
end

-- Função para encontrar o minério mais raro em workspace.Ores
local function getRarestOre()
    if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then
        return nil
    end
    local hrp = lp.Character.HumanoidRootPart
    
    local rarestOre, rarestValue, nearestDist = nil, math.huge, math.huge
    for _, ore in pairs(workspace.Ores:GetChildren()) do
        if ore:IsA("BasePart") and oreRarities[ore.Name] then
            local rarity = oreRarities[ore.Name]
            local dist = (ore.Position - hrp.Position).Magnitude
            if rarity < rarestValue or (rarity == rarestValue and dist < nearestDist) then
                rarestValue = rarity
                nearestDist = dist
                rarestOre = ore
            end
        end
    end
    return rarestOre
end

-- Função para teleportar o jogador até o minério usando TweenService
local function teleportToOre(ore)
    if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") or not ore then
        return false
    end
    local hrp = lp.Character.HumanoidRootPart
    
    -- Posiciona 1 stud acima do minério
    local targetPos = ore.Position + Vector3.new(0, 1, 0)
    local targetCFrame = CFrame.new(targetPos) * CFrame.Angles(0, math.rad(ore.Orientation.Y), 0)
    
    -- Cria o tween para movimento suave
    local tweenInfo = TweenInfo.new(
        0, -- Duração do tween corrigida para 0.5 segundos
        Enum.EasingStyle.Quad,
        Enum.EasingDirection.Out
    )
    local tween = ts:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    tween:Play()
    tween.Completed:Wait()
    return true
end

-- Função para teleportar o jogador de volta ao CFrame original
local function teleportToOriginal()
    if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") or not originalCFrame then
        return false
    end
    local hrp = lp.Character.HumanoidRootPart
    
    -- Cria o tween para movimento suave
    local tweenInfo = TweenInfo.new(
        0, -- Duração do tween
        Enum.EasingStyle.Quad,
        Enum.EasingDirection.Out
    )
    local tween = ts:Create(hrp, tweenInfo, {CFrame = originalCFrame})
    tween:Play()
    tween.Completed:Wait()
    return true
end

-- Loop de mineração para o minério selecionado
local function mineSelectedLoop()
    while isMiningSelected do
        if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then
            isMiningSelected = false
            return
        end
        
        local target = getNearestOre(selectedOre)
        if target and target.Name == selectedOre then
            local success = teleportToOre(target)
            if success and target and target.Parent then
                if target.Name == selectedOre then
                    rs.Events.MineOre:FireServer(target)
                end
            end
        else
            -- Se não houver minério selecionado, teleporta de volta ao CFrame original
            teleportToOriginal()
        end
        wait(0) -- Delay para estabilidade
    end
end

-- Loop de mineração para o minério mais raro
local function mineRarestLoop()
    while isMiningRarest do
        if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then
            isMiningRarest = false
            return
        end
        
        local target = getRarestOre()
        if target then
            local success = teleportToOre(target)
            if success and target and target.Parent then
                if oreRarities[target.Name] then
                    rs.Events.MineOre:FireServer(target)
                end
            end
        end
        wait(0) -- Delay para estabilidade
    end
end

-- Loop de mineração para o minério mais próximo (Normal Farm)
local function mineNormalLoop()
    while isMiningNormal do
        if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then
            isMiningNormal = false
            return
        end
        local hrp = lp.Character.HumanoidRootPart
        
        local target = getNearestAnyOre()
        if target then
            rs.Events.MineOre:FireServer(target)
        end
        wait(0) -- Delay para estabilidade
    end
end

-- Cria o Dropdown para selecionar o minério
local Dropdown = Tab:CreateDropdown({
    Name = "Selecionar Minério",
    Options = oreList,
    CurrentOption = "Stone",
    Flag = "OreSelection",
    Callback = function(Option)
        if type(Option) == "table" then
            selectedOre = Option[1] or "Stone"
        else
            selectedOre = Option or "Stone"
        end
    end
})

-- Cria o botão de ligar/desligar para minério selecionado
local ToggleSelected = Tab:CreateToggle({
    Name = "Auto Miner",
    CurrentValue = false,
    Flag = "AutoMinerToggle",
    Callback = function(Value)
        isMiningSelected = Value
        if isMiningSelected then
            if isMiningRarest or isMiningNormal then
                isMiningRarest = false
                isMiningNormal = false
            end
            if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then
                isMiningSelected = false
                return
            end
            -- Salva o CFrame original antes de iniciar o loop
            originalCFrame = lp.Character.HumanoidRootPart.CFrame
            spawn(mineSelectedLoop)
        end
    end
})

-- Cria o botão de ligar/desligar para farmar o minério mais raro
local ToggleRarest = Tab:CreateToggle({
    Name = "Farm Rarest Ore",
    CurrentValue = false,
    Flag = "FarmRarestToggle",
    Callback = function(Value)
        isMiningRarest = Value
        if isMiningRarest then
            if isMiningSelected or isMiningNormal then
                isMiningSelected = false
                isMiningNormal = false
            end
            if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then
                isMiningRarest = false
                return
            end
            spawn(mineRarestLoop)
        end
    end
})

-- Cria o botão de ligar/desligar para farmar o minério mais próximo
local ToggleNormal = Tab:CreateToggle({
    Name = "Normal Farm",
    CurrentValue = false,
    Flag = "NormalFarmToggle",
    Callback = function(Value)
        isMiningNormal = Value
        if isMiningNormal then
            if isMiningSelected or isMiningRarest then
                isMiningSelected = false
                isMiningRarest = false
            end
            if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then
                isMiningNormal = false
                return
            end
            spawn(mineNormalLoop)
        end
    end
})
